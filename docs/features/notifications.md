# Подсистема уведомлений

## Поток `notify()`
`notify()` — единая точка отправки событий. Она получает идентификатор типа, пользователя, бизнес-экземпляр, заголовок и необязательные данные шаблона, после чего:
1. Подключает таблицу типов уведомлений (`$NOTIFICATIONTYPES`) и ищет описание по переданному `typeID`. Если тип не найден, функция завершает работу и возвращает `false` — событие не будет доставлено.【F:src/api/notifications/main.php†L5-L27】
2. Загружает пользовательские настройки через `$bCMS->notificationSettings($userid)`, которые объединяют значения по умолчанию из `notificationTypes.php` и индивидуальные предпочтения пользователя, сохранённые в JSON. Если пользователь не найден или нужный канал отключён, функция прекращает работу.【F:src/common/libs/bCMS/bCMS.php†L234-L261】【F:src/api/notifications/main.php†L11-L26】
3. Перебирает разрешённые методы доставки (`methodsUser`) и делегирует отправку в соответствующий обработчик. Сейчас задействован только метод `1` (email), вызывающий `sendEmail()`; для метода `0` (внутренние посты) оставлен задел под реализацию.【F:src/api/notifications/main.php†L14-L24】【F:src/api/notifications/notificationTypes.php†L7-L155】

Такой конвейер позволяет централизованно расширять каналы (например, SMS или push), добавив новый идентификатор метода и реализацию в `switch`.

## Типы уведомлений и каналы
| ID | Группа | Название | Канал(ы) по умолчанию | Отключаемо пользователем | Рекомендации по кастомизации шаблонов |
| --- | --- | --- | --- | --- | --- |
| 1 | Account | Password Reset | Email | Нет | Используйте шаблон по умолчанию для строгого брендинга. |
| 2 | Account | Added to Business | Email | Нет | Добавьте блок с контактами администратора через `TEMPLATE`. |
| 3 | Account | Email verification | Email | Нет | Минимальные изменения; важно сохранять CTA. |
| 4 | Account | Magic email login link | Email | Нет | Выделите ссылку входа кнопкой в Twig-парциале. |
| 10 | Crewing | Removed from Project Crew | Email | Да | Вставьте причину через `DATA` и Twig-включение. |
| 11 | Crewing | Added to Project Crew | Email | Да | Для разных ролей подключайте специальные парциалы. |
| 12 | Maintenance | Tagged in new Maintenance Job | Email | Да | Включите список задач блоком Twig. |
| 13 | Maintenance | Sent message in Maintenance Job | Email | Да | Выводите последние сообщения циклом в частичном шаблоне. |
| 14 | Maintenance | Maintenance Job changed Status | Email | Да | Передавайте историю статусов в `DATA`. |
| 15 | Maintenance | Assigned Maintenance Job | Email | Да | Добавьте блок контактных данных ответственного. |
| 16 | Asset Groups Watching | Asset added to Group | Email | Да | Покажите мини-галерею ассета через Twig-парциал. |
| 17 | Asset Groups Watching | Asset removed from Group | Email | Да | Используйте условное сообщение (например, причина удаления). |
| 18 | Asset Groups Watching | Asset assigned to Project | Email | Да | Передавайте ссылку на проект в `DATA`. |
| 19 | Asset Groups Watching | Asset removed from Project | Email | Да | Сформируйте рекомендации по повторному назначению. |
| 20 | Crewing | Crew Role Name Changed | Email | Да | В `TEMPLATE` отобразите старое и новое название. |
| 30 | Business - Users | User added to Business using a signup code | Email | Да | Добавьте приветственный контент с инструкциями. |
| 40 | Project | Application made for a crew vacancy on a project you manage | Email | Нет | Сосредоточьтесь на кратком резюме кандидата. |
| 41 | Project | Application updates for a crew vacancy you applied to | Email | Нет | Сообщайте статус и дальнейшие шаги. |

> Примечание: все текущие типы используют только канал Email (`methods => [1]`), однако структура допускает добавление новых каналов (например, «Post», `methods => [0]`).【F:src/api/notifications/notificationTypes.php†L7-L155】

## Пользовательские настройки
`notificationSettings()` вытягивает базовые данные пользователя, декодирует сохранённые настройки и для каждого типа уведомления вычисляет итоговый набор методов: если тип можно отключить (`canDisable`), то учитывается пользовательская запись; иначе канал всегда активен.【F:src/common/libs/bCMS/bCMS.php†L234-L260】

Хранение настроек в JSON позволяет гибко расширять набор каналов без изменения структуры таблиц: достаточно сохранить новую запись `{"type": <ID>, "method": <methodId>, "setting": "true|false"}`.

## Рендер и отправка email
`sendEmail()` проверяет, что у пользователя есть адрес и что почта включена в конфигурации. Затем (при наличии `instanceID`) выбирает связанные данные инстанса, рендерит Twig-шаблон `api/notifications/email/email_template.twig` с передачей `SUBJECT`, очищенного HTML, конфигурации и произвольных данных, а также добавляет футер из настроек.【F:src/api/notifications/email/email.php†L3-L23】

Шаблон поддерживает три сценария вывода: подключение пользовательского Twig-файла через `TEMPLATE`, показ готового HTML или дефолтный текстовый блок. Это облегчает точечную кастомизацию, не ломая общую стилистику писем.【F:src/api/notifications/email/email_template.twig†L209-L259】

### Выбор провайдера
После рендера выбирается обработчик на основе `EMAILS_PROVIDER`; доступны Sendgrid, Mailgun, Postmark и SMTP. Для каждого варианта подключается соответствующий handler-класс. Неизвестный провайдер приводит к `trigger_error()` и возврату `false`, поэтому рекомендуется контролировать значение на уровне конфигурации админ-панели.【F:src/api/notifications/email/email.php†L24-L40】

### Обязательные конфигурационные ключи
Чтобы отправка работала, необходимо заполнить как минимум:
- `EMAILS_ENABLED` — включает/выключает отправку писем и вводит обязательную верификацию email.【F:src/common/libs/Config/configStructureArray.php†L47-L67】
- `EMAILS_PROVIDER` — выбирает поставщика и определяет набор дополнительных ключей.【F:src/common/libs/Config/configStructureArray.php†L68-L88】
- `EMAILS_FROMEMAIL` — адрес отправителя, валидируется как email.【F:src/common/libs/Config/configStructureArray.php†L89-L111】
- `EMAILS_PROVIDERS_APIKEY` — API-ключ для Sendgrid/Mailgun/Postmark; для SMTP вместо этого обязательны `EMAILS_SMTP_SERVER`, `EMAILS_SMTP_USERNAME`, `EMAILS_SMTP_PASSWORD`, `EMAILS_SMTP_PORT`, `EMAILS_SMTP_ENCRYPTION`. Дополнительный ключ `EMAILS_PROVIDERS_MAILGUN_LOCATION` требуется только для Mailgun.【F:src/common/libs/Config/configStructureArray.php†L112-L258】
- `EMAILS_FOOTER` — необязательный, но полезный для централизованного текста в подвале писем.【F:src/common/libs/Config/configStructureArray.php†L259-L279】

## Примеры использования
### Сценарий работы пользователя
1. Пользователь настраивает предпочитаемые каналы в профиле (включает/отключает доступные методы доставки для каждого типа).
2. При наступлении события (например, добавление в проект) сервер вызывает `notify()` с нужным `typeID` и данными.
3. Функция проверяет тип и активные каналы, после чего `sendEmail()` рендерит Twig-шаблон письма и передаёт контекст.
4. Пользователь получает письмо и, при необходимости, переходит по ссылке или отвечает; если уведомление неактуально, он обновляет настройки, чтобы отключить этот канал.

### Отправка стандартного email
```php
require_once __DIR__ . '/src/api/notifications/main.php';

// Передаём готовый HTML без отдельного шаблона
notify(11, $userId, $instanceId, 'Вас добавили в проект',
    '<p>Здравствуйте! Вы добавлены в команду проекта «Альфа».</p>');
```
Этот вызов воспользуется настройками пользователя, автоматически добавит футер и, при необходимости, загрузит данные экземпляра для брендинга письма.

### Использование Twig-парциала
```php
$context = [
    'roleName' => 'Звукорежиссёр',
    'projectUrl' => $projectUrl,
];
notify(20, $userId, $instanceId, 'Изменено название роли', false,
    'emails/crew-role-update.twig', $context);
```
Шаблон `emails/crew-role-update.twig` будет подключён через `{% include TEMPLATE %}`, поэтому его достаточно разместить в `src/` и использовать переданные данные `DATA`.

### Расширение каналов
При добавлении, например, SMS:
1. Дополните `notificationTypes.php` новым методом `2 => 'SMS'` и укажите его в массиве `methods` нужных типов.
2. Реализуйте ветку `case 2` в `notify()` для интеграции с провайдером SMS.
3. Обновите UI настроек, чтобы пользователи могли включать/отключать SMS.

## Обработка ошибок и рекомендации
- `notify()` возвращает `false`, если тип не найден или канал отключён, что позволяет вызывать её в условиях и логировать пропуски.【F:src/api/notifications/main.php†L5-L27】
- `sendEmail()` завершает работу раньше, если у пользователя нет email или глобально отключена рассылка; при неизвестном провайдере генерируется PHP-ошибка. Оборачивайте вызовы в мониторинг, чтобы отследить такие случаи.【F:src/api/notifications/email/email.php†L5-L40】
- Для кастомных Twig-шаблонов рекомендуется валидировать входные данные (`$array`) и предусматривать запасной вариант (`HTML`), чтобы письмо не оказалось пустым.
- При интеграции новых каналов учитывайте idempotency — повторные вызовы `notify()` должны быть безопасными, особенно для внешних API.

## Как это работает простыми словами
1. **Настраиваем, что получать.** Пользователь однажды отмечает в профиле, какие уведомления ему нужны и по каким каналам (сейчас это email). Система запоминает выбор и хранит его вместе со списком всех типов уведомлений.
2. **Происходит событие.** В приложении что-то случается — например, менеджер добавляет сотрудника в проект. Код вызывает функцию `notify()` и говорит ей: «Отправь уведомление типа 11 этому пользователю, тема письма такая-то, вот дополнительные данные».
3. **Система проверяет настройки.** `notify()` смотрит, разрешён ли этот канал у пользователя. Если отключён — просто возвращает `false` и ничего не отправляет. Если включён — выбирает подходящий способ доставки (сейчас это email).
4. **Собираем письмо.** Для email вызывается `sendEmail()`: она подгружает шаблон письма (стандартный или кастомный Twig), подставляет данные события и конфигурации (бренд, футер, ссылки) и формирует готовый HTML.
5. **Выбираем почтового провайдера.** В зависимости от настройки `EMAILS_PROVIDER` система подключает Sendgrid, Mailgun, Postmark или SMTP и передаёт им готовое письмо.
6. **Получатель читает письмо.** Пользователь открывает письмо, видит структурированный контент и действует: переходит по ссылке, отвечает или игнорирует. Если уведомление оказалось лишним, он возвращается к шагу 1 и отключает его.

Ключевая идея: вам не нужно вручную собирать письма или помнить, кто предпочитает какой канал. Достаточно вызвать `notify()` с нужным типом и данными — всё остальное (настройки, шаблон, отправка) произойдёт автоматически.
